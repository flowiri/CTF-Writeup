1. IP quản trị EXSI của từng đội sẽ là 172.16.1.2xx (xx là số đội, ví dụ 01 thì 172.16.1.201)
2. Công ty SBC bị tấn công và bị hacker rao bán dữ liệu mật khẩu
```plaintext
root /Lvs$3726 172.16.1.2xx
root/P@ssWord123 172.16.1.2xx
```
3. Một thiết IoT Router nằm trong hạ tầng server có IP 192.168.4.253, được mô phỏng hệ thống IoT với service và thiết bị đèn LED. Mục tiêu giữ cho service và LED được available, nếu giữ được sẽ cộng điểm và ngược lại sau mỗi round. Ngoài ra IoT còn tồn tại lỗ hổng nghiêm trọng cần được vá sớm
4. Ban tổ chức bổ sung ip ctfd: 10.10.10.6:8000
5. Các đội phải vào raspberry pi 5 của mình để tìm password wifi mà raspberry đang kết nối sẽ vào được ctfd
6. CÔNG TY SBC BỊ TẤN CÔNG MẠNG VÀ HACKER MÃ HOÁ MỘT SỐ VM, DỊCH VỤ QUAN TRỌNG. Khi vào được EXSI, hãy kiểm tra datastore sẽ thấy điều kì diệu từ ban tổ chức
7. To solve this, you must replicate the file chunking algorithm exactly. Here are the specific steps and components involved: The Algorithm is the Lorenz System: The sequence of numbers used to determine chunk sizes is generated by the Lorenz attractor (gen_lorenz). The Seed is from the File Path: The initial state (the key, or nonce) for the Lorenz system is generated by applying std::hash to the absolute file path of the input file. Critical Precision: All floating-point calculations within the Lorenz system are performed using C++ float. This is a 32-bit IEEE 754 floating-point number. You must use this exact precision. Using a 64-bit double will result in an incorrect sequence. Normalization: The raw, absolute values from the Lorenz sequence are normalized. This means they are all summed up, and then each value is divided by that total sum to get a proportion. Final Size Adjustment: After calculating the initial chunk sizes, any remaining bytes needed to match the exact file size are added to the very last chunk. Also my tung tung ti team manage to find this snippet, may it help my fellow buddy
```C++
				constexpr auto max_chunk_size = 65536;
				constexpr auto min_chunk_size = 64;
				constexpr auto max_chunks = 102400;

				static inline auto chunk_file(const std::filesystem::path & file_path,
					const chaotic::key & chaotic_key) -
				> std::vector < std::uintmax_t > {
					auto file_size = std::filesystem::file_size(file_path);

					if (file_size == 0) {
					return {};
					}

					auto desired_chunks = std::max < std::uintmax_t > (
					1,
					std::min < std::uintmax_t > (
						max_chunks, static_cast < std::uintmax_t > (std::ceil(
						static_cast < double > (file_size) / max_chunk_size))));

					auto chaotic_sequence =
					chaotic::gen_lorenz(desired_chunks, chaotic_key) |
					std::views::transform([](auto value) {
					return std::abs(value);
					}) |
					std::ranges::to < std::vector > ();

					auto selected = chaotic_sequence | std::views::take(desired_chunks) |
					std::ranges::to < std::vector > ();

					auto total = std::accumulate(selected.begin(), selected.end(), 0.0 f);

					std::vector < float > normalized;
					if (total == 0.0 f) {
					normalized.assign(desired_chunks, 1.0 f / desired_chunks);
					} else {
					normalized.reserve(desired_chunks);
					std::transform(selected.begin(), selected.end(),
						std::back_inserter(normalized),
						[total](float val) {
						return val / total;
						});
					}

					std::vector < std::uintmax_t > chunk_sizes;
					chunk_sizes.reserve(desired_chunks);
					std::transform(
					normalized.begin(), normalized.end(), std::back_inserter(chunk_sizes),
					[file_size](float proportion) {
						return std::max < std::uintmax_t > (
						min_chunk_size,
						static_cast < std::uintmax_t > (std::floor(proportion * file_size)));
					});

					auto sum_chunks = std::accumulate(chunk_sizes.begin(), chunk_sizes.end(),
					std::uintmax_t {
						0
					});
					auto diff = file_size - sum_chunks;

					if (diff != 0 && !chunk_sizes.empty()) {
					chunk_sizes.back() += diff;
					}

					return chunk_sizes;	
``` 
8. Bán source malware
9. Bán cách giải mã malware